#include <vector>
#include <string>
#include <iostream>

int main() {
    /**
     * 针对可复制的形参，在移动成本低且一定会被复制的情况下，考虑将其按值传递
     */
    {
        // 1 仅对于可复制的形参，才考虑按值传递；
        // 2 按值传递仅仅在形参成本低廉的情况下；
        // 3 在不需要重新分配内存的情况下，按值传递会导致多得多的成本；
        // 4 在调用链上传递累加会导致难以忍受的成本；
        // 5 按值传递可能遇到切片问题；
    }
    /**
     * 考虑置入而非插入
     */
    {
        {
            std::vector<std::string> vs{};
            vs.push_back("xyzzy"); // 可能会遭遇一次构造，右值构造，析构
            vs.emplace_back("xyzzy"); // 只经历一次构造
            for(const auto& s:vs) {
                std::cout<<s<<std::endl;
            }
        }
        // 需要考虑的典型情况是：
        // 1 欲添加的值是以构造而非赋值的方式加入容器
        // 2 传递的实参类型与持有物的类型不同
        // 3 容器不太可能由于重复情况而拒绝添加新的值，如set、map等
        // 4 不是使用new Widget形式的，在这种情况下，push由于析构比较安全，emplace由于构造，比较危险
        // 5 置入函数可能会执行在插入函数中拒绝的类型转换，这种情况下即使使用explicit也会因为直接初始化没有被阻止而成功编译
    }
}